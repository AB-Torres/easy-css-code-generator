/**
 * JSZip - A Javascript class for generating and reading zip files
 * <http://stuartk.com/jszip>
 *
 * (c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>
 * Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.
 *
 * JSZip uses the library pako released under the MIT license :
 * https://github.com/nodeca/pako/blob/master/LICENSE
 */
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.JSZip=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var support = require('./support');
var crc32 = require('./crc32');
var signature = require('./signature');
var pako = require('./pako');
var defaults = require('./defaults');
/**
 * Compression methods
 * @enum {number}
 */
var STORE = 0,
    DEFLATE = 8;
/**
 *  Convert a string to a "byte" array
 * @param {String} str the string to transform
 * @return {Array<number>} the string in "byte" array
 */
var string2bytes = function(str) {
    var result = [],
        i,
        len = str.length;
    for (i = 0; i < len; i++) {
        result.push(str.charCodeAt(i));
    }
    return result;
};
/**
 *  Convert a "byte" array to a string
 * @param {Array<number>} bytes the byte array to transform
 * @return {String} the array as string
 */
var bytes2string = function(bytes) {
    var result = "",
        i,
        len = bytes.length;
    for (i = 0; i < len; i++) {
        result += String.fromCharCode(bytes[i]);
    }
    return result;
};
/**
 *  Merge the objects
 * @private
 * @param {Object} options the object to merge in the defaults
 * @param {Object} defaults the default values
 * @return {Object} the merged object
 */
var extend = function(options, defaults) {
    var prop, result = {};
    for (prop in defaults) {
        if (defaults.hasOwnProperty(prop)) {
            result[prop] = defaults[prop];
        }
    }
    if (options) {
        for (prop in options) {
            if (options.hasOwnProperty(prop)) {
                result[prop] = options[prop];
            }
        }
    }
    return result;
};
/**
 *  Helpers for the file header
 * @private
 */
var fileHeaderHelper = {
    /**
     *  Default values for a local file header
     */
    LOCAL_FILE_HEADER_BASE: [
        // version needed to extract                       2 bytes
        10, 0,
        // general purpose bit flag                        2 bytes
        0, 0,
        // compression method                              2 bytes
        0, 0,
        // last mod file time                              2 bytes
        0, 0,
        // last mod file date                              2 bytes
        0, 0,
        // crc-32                                          4 bytes
        0, 0, 0, 0,
        // compressed size                                 4 bytes
        0, 0, 0, 0,
        // uncompressed size                               4 bytes
        0, 0, 0, 0,
        // file name length                                2 bytes
        0, 0,
        // extra field length                              2 bytes
        0, 0
    ],
    /**
     *  "Data descriptor" - see https://pkware.cachefly.net/webdocs/APPNOTE/v6.3.3/appnote.txt
     * @private
     */
    DATA_DESCRIPTOR: [
        // crc-32                                          4 bytes
        0, 0, 0, 0,
        // compressed size                                 4 bytes
        0, 0, 0, 0,
        // uncompressed size                               4 bytes
        0, 0, 0, 0
    ],
    /**
     *  Default values for a central directory file header
     */
    CENTRAL_FILE_HEADER_BASE: [
        // central file header signature   4 bytes
        0x50, 0x4b, 0x01, 0x02,
        // version made by                 2 bytes
        20, 0,
        // version needed to extract       2 bytes
        10, 0,
        // general purpose bit flag        2 bytes
        0, 0,
        // compression method              2 bytes
        0, 0,
        // last mod file time              2 bytes
        0, 0,
        // last mod file date              2 bytes
        0, 0,
        // crc-32                          4 bytes
        0, 0, 0, 0,
        // compressed size                 4 bytes
        0, 0, 0, 0,
        // uncompressed size               4 bytes
        0, 0, 0, 0,
        // file name length                2 bytes
        0, 0,
        // extra field length              2 bytes
        0, 0,
        // file comment length             2 bytes
        0, 0,
        // disk number start               2 bytes
        0, 0,
        // internal file attributes        2 bytes
        0, 0,
        // external file attributes        4 bytes
        0, 0, 0, 0
    ],
    /**
     *  Default values for the end of central directory records
     */
    CENTRAL_DIRECTORY_END_BASE: [
        // end of central dir signature    4 bytes
        0x50, 0x4b, 0x05, 0x06,
        // number of this disk             2 bytes
        0, 0,
        // number of the disk with the
        // start of the central directory  2 bytes
        0, 0,
        // total number of entries in the
        // central directory on this disk  2 bytes
        0, 0,
        // total number of entries in
        // the central directory           2 bytes
        0, 0,
        // size of the central directory   4 bytes
        0, 0, 0, 0,
        // offset of start of central
        // directory with respect to
        // the starting disk number        4 bytes
        0, 0, 0, 0,
        // .ZIP file comment length        2 bytes
        0, 0
    ],
    /**
     *  Prepare the buffer for a new file
     * @param {String} fileName the name of the file
     * @param {Object} options the options of the file
     * @param {Object} compressed the compressed data
     * @return {Object} the buffer ready for the local file header
     */
    prepareFileHeader: function(fileName, options, compressed) {
        var compressedSize = compressed.compressedSize,
            uncompressedSize = compressed.uncompressedSize,
            crc32value = compressed.crc32,
            fileHeader = utils.clone(this.LOCAL_FILE_HEADER_BASE),
            nameByteArray = string2bytes(fileName);
        
        // general purpose bit flag
        if (options.bitFlag) {
            fileHeader[4] = options.bitFlag[0];
            fileHeader[5] = options.bitFlag[1];
        }
        
        // compression method
        fileHeader[6] = options.compression === STORE ? 0 : 8;
        
        // last mod file time/date
        var lastMod = options.date.toDosDateTime();
        fileHeader[8] = lastMod.time;
        fileHeader[9] = lastMod.time >> 8;
        fileHeader[10] = lastMod.date;
        fileHeader[11] = lastMod.date >> 8;
        
        // crc-32
        fileHeader[12] = crc32value;
        fileHeader[13] = crc32value >> 8;
        fileHeader[14] = crc32value >> 16;
        fileHeader[15] = crc32value >> 24;
        
        // compressed size
        fileHeader[16] = compressedSize;
        fileHeader[17] = compressedSize >> 8;
        fileHeader[18] = compressedSize >> 16;
        fileHeader[19] = compressedSize >> 24;
        
        // uncompressed size
        fileHeader[20] = uncompressedSize;
        fileHeader[21] = uncompressedSize >> 8;
        fileHeader[22] = uncompressedSize >> 16;
        fileHeader[23] = uncompressedSize >> 24;
        
        // file name length
        fileHeader[24] = nameByteArray.length;
        fileHeader[25] = nameByteArray.length >> 8;
        
        return {
            fileHeader: fileHeader,
            nameByteArray : nameByteArray
        };
    },
    /**
     *  Prepare the buffer for the central directory header
     * @param {Object} header the header data for this file
     * @param {Object} compressed the compressed data
     * @param {number} offset the offset of the file
     * @param {String} comment the comment for this file
     * @param {Object} options the options of the file
     * @return {Object} the buffer ready for the central directory
     */
    prepareCentralFileHeader: function(header, compressed, offset, comment, options) {
        var compressedSize = compressed.compressedSize,
            uncompressedSize = compressed.uncompressedSize,
            crc32value = compressed.crc32,
            centralFileHeader = utils.clone(this.CENTRAL_FILE_HEADER_BASE),
            nameByteArray = header.nameByteArray,
            commentByteArray = string2bytes(comment),
            lastMod = options.date.toDosDateTime();

        // version needed to extract
        centralFileHeader[8] = 10;
        centralFileHeader[9] = 0;
        
        // general purpose bit flag
        if (options.bitFlag) {
            centralFileHeader[10] = options.bitFlag[0];
            centralFileHeader[11] = options.bitFlag[1];
        }
        
        // compression method
        centralFileHeader[12] = options.compression === STORE ? 0 : 8;
        
        // last mod file time/date
        centralFileHeader[14] = lastMod.time;
        centralFileHeader[15] = lastMod.time >> 8;
        centralFileHeader[16] = lastMod.date;
        centralFileHeader[17] = lastMod.date >> 8;
        
        // crc-32
        centralFileHeader[18] = crc32value;
        centralFileHeader[19] = crc32value >> 8;
        centralFileHeader[20] = crc32value >> 16;
        centralFileHeader[21] = crc32value >> 24;
        
        // compressed size
        centralFileHeader[22] = compressedSize;
        centralFileHeader[23] = compressedSize >> 8;
        centralFileHeader[24] = compressedSize >> 16;
        centralFileHeader[25] = compressedSize >> 24;
        
        // uncompressed size
        centralFileHeader[26] = uncompressedSize;
        centralFileHeader[27] = uncompressedSize >> 8;
        centralFileHeader[28] = uncompressedSize >> 16;
        centralFileHeader[29] = uncompressedSize >> 24;
        
        // file name length
        centralFileHeader[30] = nameByteArray.length;
        centralFileHeader[31] = nameByteArray.length >> 8;
        
        // extra field length
        centralFileHeader[32] = 0;
        centralFileHeader[33] = 0;
        
        // file comment length
        centralFileHeader[34] = commentByteArray.length;
        centralFileHeader[35] = commentByteArray.length >> 8;
        
        // disk number start
        centralFileHeader[36] = 0;
        centralFileHeader[37] = 0;
        
        // internal file attributes
        centralFileHeader[38] = 0;
        centralFileHeader[39] = 0;
        
        // external file attributes
        centralFileHeader[40] = 0;
        centralFileHeader[41] = 0;
        centralFileHeader[42] = 0;
        centralFileHeader[43] = options.dir ? 0x10 : 0x00;
        
        return {
            centralFileHeader: centralFileHeader,
            nameByteArray : nameByteArray,
            commentByteArray: commentByteArray,
            offset: offset
        };
    },
    /**
     *  Prepare the buffer for the end of central directory records
     * @param {number} entriesCount the number of entries in the central dir
     * @param {number} centralDirSize the size of the central dir
     * @param {number} centralDirOffset the offset of the central dir
     * @param {String} comment the zip file comment
     * @return {Array<number>} the buffer for the end of central directory record
     */
    prepareCentralDirectoryEnd: function(entriesCount, centralDirSize, centralDirOffset, comment) {
        var centralDirectoryEnd = utils.clone(this.CENTRAL_DIRECTORY_END_BASE),
            commentByteArray = string2bytes(comment);

        // total number of entries in the central directory on this disk
        centralDirectoryEnd[8] = entriesCount;
        centralDirectoryEnd[9] = entriesCount >> 8;

        // total number of entries in the central directory
        centralDirectoryEnd[10] = entriesCount;
        centralDirectoryEnd[11] = entriesCount >> 8;

        // size of the central directory
        centralDirectoryEnd[12] = centralDirSize;
        centralDirectoryEnd[13] = centralDirSize >> 8;
        centralDirectoryEnd[14] = centralDirSize >> 16;
        centralDirectoryEnd[15] = centralDirSize >> 24;

        // offset of start of central directory with respect to the starting disk number
        centralDirectoryEnd[16] = centralDirOffset;
        centralDirectoryEnd[17] = centralDirOffset >> 8;
        centralDirectoryEnd[18] = centralDirOffset >> 16;
        centralDirectoryEnd[19] = centralDirOffset >> 24;

        // zip file comment length
        centralDirectoryEnd[20] = commentByteArray.length;
        centralDirectoryEnd[21] = commentByteArray.length >> 8;
        
        return {
          centralDirectoryEnd : centralDirectoryEnd,
          commentByteArray : commentByteArray
        };
    },
    /**
     *  Get the data ready to be written
     * @param {Array<number>} header the header data
     * @param {Array<number>} nameByteArray the name as byte array
     * @param {Array<number>} commentByteArray the comment as byte array
     * @param {Array<number>} data the data
     * @return {Array<number>} the data ready to be written
     */
    getBinaryData: function(header, nameByteArray, commentByteArray, data) {
        var result = [];
        utils.append(result, header);
        utils.append(result, nameByteArray);
        utils.append(result, data);
        if (commentByteArray) {
          utils.append(result, commentByteArray);
        }
        return result;
    },
    /**
     *  Get the data ready to be written for the central dir
     * @param {Array<number>} header the header data
     * @param {Array<number>} nameByteArray the name as byte array
     * @param {Array<number>} commentByteArray the comment as byte array
     * @return {Array<number>} the data ready to be written
     */
    getCentralDirectoryBinaryData: function(header, nameByteArray, commentByteArray) {
        var result = [];
        utils.append(result, header);
        utils.append(result, nameByteArray);
        utils.append(result, commentByteArray);
        return result;
    }
};
/**
 *  A class to represent a Zip file in js
 * @constructor
 */
function JSZip() {
    /**
     *  The files added in the zip
     * @type {Object}
     * @private
     */
    this.files = {};
    this.comment = null;
    /**
     * The options used when creating the zip file
     * @type {Object}
     * @private
     */
    this.options = {
        compression: defaults.compression,
        compressionOptions : defaults.compressionOptions
    };
}
JSZip.prototype = {
    /**
     *  Set the zip comment.
     * @param {String} comment the comment of the zip.
     * @return {JSZip} this instance.
     */
    comment : function (comment) {
        this.comment = comment;
        return this;
    },
    /**
     *  Set the options.
     * @param {Object} options the options of the zip file.
     *  The available options are :
     *  - `compression` : `"STORE"` or `"DEFLATE"`, `DEFLATE` by default.
     *  - `compressionOptions` : an object containing the options for the compressor.
     * @return {JSZip} this instance.
     */
    options : function (options) {
        if (options.compression !== undefined) {
           this.options.compression = options.compression;
        }
        if (options.compressionOptions !== undefined) {
            this.options.compressionOptions = options.compressionOptions;
        }
        return this;
    },
    /**
     *  Add a file in the zip file
     * @param {String} name the name of the file
     * @param {String|Array<number>|Uint8Array|Buffer} data the data of the file
     * @param {Object} options the options of the file
     * @return {JSZip} this instance.
     */
    file: function(name, data, options) {
        if (!name) {
            throw new Error("Filename must not be empty");
        }
        options = extend(options || {}, defaults);
        if (options.date == null) {
            options.date = new Date();
        }
        
        if (typeof data === "string") {
            data = string2bytes(data);
        }
        
        var compressed = this._compress(name, data, options);
        
        this.files[name] = {
            name: name,
            data: data,
            options: options,
            dir: false,
            compressed: compressed
        };
        return this;
    },
     /**
     * Add a directory to the zip file
     * @param {String} name the directory name
     * @return {JSZip} this instance
     */
    folder : function(name) {
        if (!name) {
           throw new Error("Folder name must not be empty");
        }
       
        if(name.slice(-1) != "/") {
            name += "/";
        }
        
        this.files[name] = {
            name: name,
            data: null,
            options: extend({
                dir:true
            }, defaults),
            dir: true
        };
        return this;
    },
    /**
     *  Get a file from the zip file
     * @param {String} name the name of the file
     * @return {JSZipObject|null} the file
     */
    file : function (name) {
        if (this.files[name]) {
            return new JSZipObject(this, this.files[name]);
        }
        return null;
    },
    /**
     *  Returns an array containing the names of the files and folders in the zip.
     * @return {Array<string>} the names of the files and folders in the zip.
     */
    filter : function (filter) {
      var result = [],
          filename,
          relative;
      for(filename in this.files) {
        if(this.files.hasOwnProperty(filename)){
          relative = filename.replace(/^\//, "");
          if (filter(relative, this.files[filename])) {
             result.push(filename);
          }
        }
      }
      return result;
    },
    /**
     *  Returns an array containing the names of the files and folders in the zip.
     * @return {Array<string>} the names of the files and folders in the zip.
     */
    getFiles : function () {
      return this.filter(function(relative, file) {
        return !file.dir;
      });
    },
    /**
     *  Returns an array containing the names of the folders in the zip.
     * @return {Array<string>} the names of the folders in the zip.
     */
    getFolders : function () {
      return this.filter(function(relative, file) {
        return file.dir;
      });
    },
    /**
     *  Generate the complete zip file
     * @param {Object} options the options for the generation
     * @return {Array<number>|Buffer|Uint8Array} the zip file
     */
    generate: function(options) {
        options = extend(options || {}, defaults);
        var file,
            files = [],
            entriesCount = 0,
            centralDirSize = 0,
            centralDirOffset = 0,
            output = [],
            offset = 0,
            directory = "",
            i,
            data;

        for (file in this.files) {
            if (this.files.hasOwnProperty(file)) {
                entriesCount++;
                file = this.files[file];

                if (!file.dir) {
                    data = fileHeaderHelper.prepareFileHeader(file.name, file.options, file.compressed);

                    files.push({
                        fileHeader: data.fileHeader,
                        nameByteArray : data.nameByteArray,
                        data: file.compressed.data,
                        comment: "",
                        options : file.options
                     });
                } else {
                     data = fileHeaderHelper.prepareFileHeader(file.name, file.options, { compressedSize: 0, uncompressedSize:0, crc32: 0});
                    files.push({
                        fileHeader: data.fileHeader,
                        nameByteArray : data.nameByteArray,
                        data: [],
                        comment: "",
                         options : file.options
                    });
                }
            }
        }
        for(i=0; i < files.length; i++) {
          file = files[i];
           var fileData = fileHeaderHelper.getBinaryData(
                               file.fileHeader,
                               file.nameByteArray,
                               null,
                               file.data
                           );
           utils.append(output, fileData);
        }
        offset = output.length;
       
       for(i=0; i < files.length; i++) {
          file = files[i];
            var centralDirData = fileHeaderHelper.prepareCentralFileHeader(
               file,
               file.options.dir ? { compressedSize: 0, uncompressedSize:0, crc32: 0} :  file.compressed ,
               offset,
               file.comment,
               file.options
            );
           var centralDirFile = fileHeaderHelper.getCentralDirectoryBinaryData(
                               centralDirData.centralFileHeader,
                               centralDirData.nameByteArray,
                               centralDirData.commentByteArray
                           );
           utils.append(output, centralDirFile);
           centralDirSize += centralDirFile.length;
           offset += fileData.length;
        }
       
        var endDirData = fileHeaderHelper.prepareCentralDirectoryEnd(
                entriesCount,
                centralDirSize,
                offset,
                this.comment
        );
       
       utils.append(output, fileHeaderHelper.getBinaryData(
          endDirData.centralDirectoryEnd,
          null,
          endDirData.commentByteArray,
          null
        ));
       
        return utils.transformTo(output, options.type);
    },
    /**
     *  Compress the "data" with the specified method.
     * @param {String} name the name of the entry.
     * @param {Array<number>} data the data to compress.
     * @param {Object} options the options of the file.
     * @return {Object} the compressed data.
     * @private
     */
    _compress: function(name, data, options) {
        var compressed,
            crc32value = 0;

        if (options.compression === STORE) {
          compressed = data;
        } else {
          compressed = pako.deflate(data, this.options.compressionOptions);
        }
        
        crc32value = crc32(data);
       
        return {
            data: compressed,
            compressedSize: compressed.length,
            uncompressedSize: data.length,
            crc32: crc32value
        };
    }
};
/**
 *  A class to represent an entry in the zip file
 * @constructor
 * @param {JSZip} zip the parent zip file
 * @param {Object} file the file data
 */
function JSZipObject(zip, file) {
    /**
     * The zip file
     * @type {JSZip}
     */
    this.zip = zip;
    /**
     * The file data
     * @type {Object}
     */
    this.file = file;
}
JSZipObject.prototype = {
    /**
     *  Return the content of the file
     * @param {String} type the type of the result. The available values are : string, uint8array, arraybuffer.
     * @return {String|Uint8Array|ArrayBuffer} the data of the file.
     */
    as : function(type) {
       return utils.transformTo(this.file.data, type);
    },
     /**
      *  Prepare the file for a download.
      * @param {String} filename the name of the file.
      * @param {Object} options the options for the download.
      * @return {Object} the download object.
      */
    download : function (filename, options) {
       
        options = extend(options || {}, defaults);

        var output = this.zip.generate(options);
        var mimeType = "application/zip";
      
        if (options.mimeType) {
          mimeType = options.mimeType;
        }
       
        return {
          blob : function() {
            if(!support.blob) {
               throw new Error("The current browser doesn't support the Blob object");
            }
            return utils.createBlob(output, mimeType);
          },
          url : function() {
            if(!support.blob) {
              throw new Error("The current browser doesn't support the Blob object");
            }
            return utils.createObjectURL(utils.createBlob(output, mimeType));
          } ,
          href : function () {
            if(!support.blob) {
              throw new Error("The current browser doesn't support the Blob object");
            }
           return utils.createObjectURL(utils.createBlob(output, mimeType));
          }
        };
    }
};
JSZip.STORE = STORE;
JSZip.DEFLATE = DEFLATE;
module.exports = JSZip;
},{"./crc32":2,"./defaults":3,"./pako":6,"./signature":7,"./support":8,"./utils":9}],2:[function(require,module,exports){
'use strict';
/**
 *  Based on работник's solution : https://gist.github.com/1200178
 */
var crc32 = (function() {
    var table = null;
    var crc32 = function(bytes) {
        if (!table) {
            table = (function() {
                var i, j, t, tab = [];
                for (i = 0; i < 256; i++) {
                    t = i;
                    for (j = 0; j < 8; j++) {
                        t = (t & 1) ? (t >>> 1) ^ 0xEDB88320 : t >>> 1;
                    }
                    tab[i] = t;
                }
                return tab;
            }());
        }
        var crc = 0 ^ -1,
            i,
            len = bytes.length;
        for (i = 0; i < len; i++) {
            crc = (crc >>> 8) ^ table[(crc ^ bytes[i]) & 0xFF];
        }
        return (crc ^ -1) >>> 0;
    };
    return crc32;
}());
module.exports = crc32;
},{}],3:[function(require,module,exports){
'use strict';
module.exports = {
    /**
     *  The default mime-type of the generated content.
     * @type {String}
     */
    mimeType : "application/zip",
     /**
      *  The default compression method.
      * @type {String}
      */
    compression : "DEFLATE",
    /**
      * The default level of compression for DEFLATE.
      */
    compressionOptions : {
        level: 6
    },
     /**
      * The type of the result.
      * @type {String}
      */
    type : "",
      /**
       *  The date of the file.
       * @type {Date}
       */
     date : null
};
},{}],4:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var support = require('./support');
var nodeBuffer = require('./nodeBuffer');
/**
 *  Convert a string to a "byte" array.
 * @param {String} str the string to transform.
 * @return {Array<number>} the string in "byte" array.
 */
var string2bytes = function(str) {
    var result = [],
        i,
        len = str.length;
    for (i = 0; i < len; i++) {
        result.push(str.charCodeAt(i));
    }
    return result;
};
/**
 *  Create a blob.
 * @param {Array<number>|Buffer} data the data to use.
 * @param {String} mimeType the mime type of the blob.
 * @return {Blob} the created blob.
 */
var createBlob = function(data, mimeType) {
    var blob;
    if (support.blob) {
        try {
            blob = new Blob([data], {
                type: mimeType
            });
        }
        catch (e) {
            // TypeError old chrome and FF
            blob = new Blob([utils.transformTo(data, "arraybuffer")], {
                type: mimeType
            });
        }
    }
    else {
        blob = new nodeBuffer(data);
    }
    return blob;
};
/**
 *  Create a an object url.
 * @param {Blob} blob the blob to use.
 * @return {String} the created url.
 */
var createObjectURL = function(blob) {
  var urlCreator = (window.URL || window.webkitURL || window.mozURL || window.msURL);
  if(urlCreator) {
    return urlCreator.createObjectURL(blob);
  }
  return "";
};
/**
 *  Generate the data uri.
 * @param {Array<number>|Buffer} data the data to use.
 * @param {String} mimeType the mime type of the data uri.
 * @return {String} the data uri.
 */
var generateDataURI = function(data, mimeType) {
    var base64 = "";
    var string = "";
    var i;
    var len = data.length;
    
    for(i=0; i < len; i++) {
      string += String.fromCharCode(data[i]);
    }
    base64 = btoa(string);
    return "data:" + mimeType + ";base64," + base64;
};
/**
 *  Transform an array of numbers in a string
 * @param {Array<number>} array the array to transform
 * @return {String} the string
 */
var array2String = function(array) {
    var result = "",
        i;
    for (i = 0; i < array.length; i++) {
        result += String.fromCharCode(array[i]);
    }
    return result;
};
/**
 *  Transform an array of numbers in a string
 * @param {String} str the string to transform
 * @return {Array<number>} the array
 */
var string2Array = function(str) {
    var result = [],
        i;
    for (i = 0; i < str.length